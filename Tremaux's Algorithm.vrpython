{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      Tremaux's Algorithm\n#\tAuthor:       Will Turner\n#\tCreated:\n#\tDescription:  Maze solver using Tremaux's algorithm\n# \n# ------------------------------------------\nimport random\n\n# Checks for collisions\ndef is_valid_move():\n    distance = front_distance.get_distance(MM)    \n    return distance > 70\n\n# Rounds a heading to nearest 90 degrees\ndef round_heading(heading):\n    return (round(heading / 90) * 90 % 360)\n\n# Returns new location after a move\ndef update_location(location, heading):\n    direction = round_heading(heading)\n\n    if direction == 0:\n        location = (location[0], location[1] + 1)\n    elif direction == 90:\n        location = (location[0] + 1, location[1])\n    elif direction == 180:\n        location = (location[0], location[1] - 1)\n    elif direction == 270:\n        location = (location[0] - 1, location[1])\n    brain.print(location)\n    return location\n\n# Couples location updates to moves\ndef drive_forward(location, squareSize):\n    drivetrain.drive_for(FORWARD, squareSize, MM)\n    return (update_location(location, drivetrain.heading(DEGREES)))\n\n\n\n# Find the available openings in an unexplored node\ndef explore_node():\n\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    openings = []\n    for i in range(3):\n        side = round(drivetrain.heading(DEGREES)/90)\n        if (is_valid_move()):\n            openings.append([side, 0])\n        drivetrain.turn_for(RIGHT, 90, DEGREES)\n    side = round(drivetrain.heading(DEGREES)/90)\n    openings.append([side, 1])\n    drivetrain.turn_for(LEFT, 180, DEGREES)\n    brain.print(openings)\n    return openings\n\n\n\n\n\ndef main():\n\n    SQUARE_SIZE = 250\n    location = (0,0)\n    pen.move(DOWN)    \n\n    nodes = []\n    nodes.append(Node((0,0), (explore_node())))\n    \n    while not down_eye.detect(RED):\n        #examine node at your location\n        #pick random unmarked direction\n        # mark current node in that direction\n        # move in that direction until next node\n        # explore if new\n        # otherwise pick next node\n\n     \n        for n in nodes:\n            if n.location == location:\n                \n                direction = random.choice([o for o in n.openings if o[1] == 0])\n                n.add_mark(direction[0])\n                drivetrain.turn_to_heading(direction[0] * 90, DEGREES)\n        \n        \n\n\n\n        wait(50, MSEC)\n                \n       \n       \n            \n\n\n\nclass Node:\n    def __init__(self, location, openings):\n        self.location = location\n        self.openings = openings\n\n    def add_opening(self, opening):\n        for x in self.openings:\n            if x[0] == opening[0]: # If already exists\n                return False\n        self.openings.append(opening)\n        return True\n\n    def add_mark(self, side):\n        for x in self.openings:\n            if x[0] == side:\n                x[1] += 1\n\n        \n   \n\n# VR threads â€” Do not delete\nvr_thread(main)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}