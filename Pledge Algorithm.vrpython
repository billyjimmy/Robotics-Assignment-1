{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      Pledge Algorithm\n#\tAuthor:       Will Turner\n#\tCreated:\n#\tDescription:  Maze solver using pledge algorithm for avoiding obstacles\n# \n# ------------------------------------------\n\n\n# Checks for collisions and the start wall gap\ndef is_valid_move(location):\n    distance = front_distance.get_distance(MM)    \n    return distance > 70 and (not (drivetrain.heading(DEGREES) == 180 and location[1] == 0))\n\n# Rounds a heading to nearest 90 degrees\ndef round_heading(heading):\n    return (round(heading / 90) * 90 % 360)\n\n# Returns new location after a move\ndef update_location(location, heading):\n    direction = round_heading(heading)\n\n    if direction == 0:\n        location = (location[0], location[1] + 1)\n    elif direction == 90:\n        location = (location[0] + 1, location[1])\n    elif direction == 180:\n        location = (location[0], location[1] - 1)\n    elif direction == 270:\n        location = (location[0] - 1, location[1])\n    brain.print(location)\n    return location\n\n# Couples location updates to moves\ndef drive_forward(location, squareSize):\n    drivetrain.drive_for(FORWARD, squareSize, MM)\n    return (update_location(location, drivetrain.heading(DEGREES)))\n\n# Turns the robot, and tracks total turn count for the pledge algorithm\ndef turn(direction, angle = 90):\n    drivetrain.turn_for(direction,angle,DEGREES)\n    if direction == RIGHT:\n        return (angle / 90)\n    return 0 - (angle / 90)\n\n\ndef invert_side(side):\n    if side == LEFT:\n        return RIGHT\n    return LEFT\n\n\n\n\ndef main():\n\n    SQUARE_SIZE = 250\n    location = (0,0)    \n    direction = 0\n    turns = 0\n    pen.move(DOWN)\n    monitor_variable(\"location\", \"turns\")\n\n    \n    drivetrain.turn_to_heading(direction, DEGREES)\n    \n    while down_eye.detect(RED) == False: # Until end is reached      \n        if (is_valid_move(location)) and turns == 0:\n            location = drive_forward(location, SQUARE_SIZE)\n        else: # When hitting a wall, start wall following\n            turns += turn(RIGHT,90)\n            side = LEFT\n                       \n            while turns != 0 and down_eye.detect(RED) == False: # Until the end, or we are travelling in the original direction\n                brain.print(turns)\n                brain.new_line()\n                if (is_valid_move(location)):\n                    location = drive_forward(location, SQUARE_SIZE)\n                    turns += turn(side, 90)\n                else:                    \n                    turns += turn(invert_side(side), 90)\n            wait(20,MSEC) \n    \n# VR threads â€” Do not delete\nvr_thread(main)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}